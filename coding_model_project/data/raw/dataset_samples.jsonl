{"dataset": "humaneval", "problem_id": "HumanEval/0", "prompt": "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "test_cases": {"type": "humaneval", "test_code": "\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n", "entry_point": "has_close_elements"}, "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n", "description": "HumanEval 是 OpenAI 发布的代码生成基准，包含 164 道 Python 编程题。每道题提供函数签名和 docstring，要求生成函数体。测试用例格式为 Python assert 语句。"}
{"dataset": "mbpp_reg", "problem_id": "11", "prompt": "Write a python function to remove first and last occurrence of a given character from the string.", "test_cases": {"type": "mbpp", "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "test_setup_code": "", "challenge_test_list": ["assert remove_Occ(\"hellolloll\",\"l\") == \"helollol\"", "assert remove_Occ(\"\",\"l\") == \"\""]}, "canonical_solution": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ", "description": "MBPP (Mostly Basic Python Programming) 是 Google 发布的 Python 编程基准。prompt 是自然语言题目描述，测试用例格式为 assert 语句列表。MBPP Regular 子集包含 ID 11-210 共 200 道题。"}
{"dataset": "codecontests_valid", "problem_id": "Codeforces/1548/C", "prompt": "# The Three Little Pigs\n\nThree little pigs from all over the world are meeting for a convention! Every minute, a triple of 3 new pigs arrives on the convention floor. After the n-th minute, the convention ends.\n\nThe big bad wolf has learned about this convention, and he has an attack plan. At some minute in the convention, he will arrive and eat exactly x pigs. Then he will get away.\n\nThe wolf wants Gregor to help him figure out the number of possible attack plans that involve eating exactly x pigs for various values of x (1 ≤ x ≤ 3n). Two attack plans are considered different, if they occur at different times or if the sets of little pigs to eat are different.\n\nNote that all queries are independent, that is, the wolf does not eat the little pigs, he only makes plans!\n\nInput\n\nThe first line of input contains two integers n and q (1 ≤ n ≤ 10^6, 1 ≤ q ≤ 2⋅ 10^5), the number of minutes the convention lasts and the number of queries the wolf asks.\n\nEach of the next q lines contains a single integer x_i (1 ≤ x_i ≤ 3n), the number of pigs the wolf will eat in the i-th query.\n\nOutput\n\nYou should print q lines, with line i representing the number of attack plans if the wolf wants to eat x_i pigs. Since each query answer can be large, output each answer modulo 10^9+7.\n\nExamples\n\nInput\n\n\n2 3\n1\n5\n6\n\n\nOutput\n\n\n9\n6\n1\n\n\nInput\n\n\n5 4\n2\n4\n6\n8\n\n\nOutput\n\n\n225\n2001\n6014\n6939\n\nNote\n\nIn the example test, n=2. Thus, there are 3 pigs at minute 1, and 6 pigs at minute 2. There are three queries: x=1, x=5, and x=6.\n\nIf the wolf wants to eat 1 pig, he can do so in 3+6=9 possible attack plans, depending on whether he arrives at minute 1 or 2.\n\nIf the wolf wants to eat 5 pigs, the wolf cannot arrive at minute 1, since there aren't enough pigs at that time. Therefore, the wolf has to arrive at minute 2, and there are 6 possible attack plans.\n\nIf the wolf wants to eat 6 pigs, his only plan is to arrive at the end of the convention and devour everybody.\n\nRemember to output your answers modulo 10^9+7!", "test_cases": {"type": "codecontests", "tests": [{"input": "2 3\n1\n5\n6\n", "output": "9\n6\n1\n"}, {"input": "5 4\n2\n4\n6\n8\n", "output": "225\n2001\n6014\n6939\n"}]}, "description": "CodeContests 是 DeepMind 发布的编程竞赛数据集，题目来自 Codeforces 等编程竞赛网站。题目描述较长，包含完整的输入输出格式说明。测试用例格式为 stdin/stdout 对，即输入输出字符串。此样本来自验证集 (valid split)。", "solutions": ["import sys\n\ndef solve():\n    input_data = sys.stdin.read().split()\n    idx = 0\n    n = int(input_data[idx]); idx += 1\n    q = int(input_data[idx]); idx += 1\n    \n    MOD = 10**9 + 7\n    max_val = 3 * n + 1\n    fact = [1] * (max_val + 1)\n    for i in range(1, max_val + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact = [1] * (max_val + 1)\n    inv_fact[max_val] = pow(fact[max_val], MOD - 2, MOD)\n    for i in range(max_val - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def C(n, r):\n        if r < 0 or r > n:\n            return 0\n        return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\n    \n    answers = [0] * (3 * n + 2)\n    for i in range(1, n + 1):\n        pigs = 3 * i\n        for x in range(1, pigs + 1):\n            answers[x] = (answers[x] + C(pigs, x)) % MOD\n    \n    results = []\n    for _ in range(q):\n        x = int(input_data[idx]); idx += 1\n        results.append(str(answers[x]))\n    \n    print('\\n'.join(results))\n\nsolve()\n"]}
{"dataset": "codecontests_test", "problem_id": "Codeforces/1575/A", "prompt": "# Another Sorting Problem\n\nAndi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title — a string s_i numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\n\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\n\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\n\n  * if it is an odd position, the string a has a letter that appears earlier in the alphabet than the corresponding letter in b; \n  * if it is an even position, the string a has a letter that appears later in the alphabet than the corresponding letter in b. \n\nInput\n\nThe first line contains two integers n and m (1 ≤ n ⋅ m ≤ 10^6).\n\nThe i-th of the next n lines contains a string s_i consisting of m uppercase Latin letters — the book title. The strings are pairwise distinct.\n\nOutput\n\nOutput n integers — the indices of the strings after they are sorted asc-desc-endingly.\n\nExample\n\nInput\n\n\n5 2\nAA\nAB\nBB\nBA\nAZ\n\n\nOutput\n\n\n5 2 1 3 4\n\nNote\n\nThe following illustrates the first example.\n\n<image>", "test_cases": {"type": "codecontests", "tests": [{"input": "5 2\nAA\nAB\nBB\nBA\nAZ\n", "output": "5 2 1 3 4 \n"}]}, "description": "CodeContests 测试集样本。与验证集格式相同，用于最终评测。", "solutions": ["import sys\n\ndef solve():\n    data = sys.stdin.read().split('\\n')\n    n, m = map(int, data[0].split())\n    \n    strings = []\n    for i in range(1, n + 1):\n        if i < len(data) and data[i]:\n            strings.append((data[i], i))\n    \n    def key_func(item):\n        s, idx = item\n        result = []\n        for pos, ch in enumerate(s, 1):\n            if pos % 2 == 1:\n                result.append(ord(ch))\n            else:\n                result.append(-ord(ch))\n        return result\n    \n    strings.sort(key=key_func)\n    \n    result = ' '.join(str(idx) for s, idx in strings)\n    print(result)\n\nsolve()\n"]}
{"dataset": "codecontests_train", "problem_id": "CodeContests_train_sample", "prompt": "(训练集文件太大无法直接读取，格式与验证集/测试集相同)", "test_cases": {"type": "codecontests", "tests": []}, "description": "CodeContests 训练集包含约 13000 道编程竞赛题目，用于 RL 训练。格式与验证集相同。"}
